import parse, {} from '../../vendor/bash-parser/index.js';
import { debugLogObject } from '../util/debug.js';
import { toBinary } from '../util/protocols.js';
import * as FallbackResolver from './resolvers/fallback.js';
import KnownResolvers from './resolvers/index.js';
import { parseNodeArgs } from './resolvers/node.js';
import { trimBinary } from './util.js';
const spawningBinaries = ['cross-env', 'retry-cli'];
const isExpansion = (node) => 'expansion' in node;
const isAssignment = (node) => 'type' in node && node.type === 'AssignmentWord';
export const getBinariesFromScript = (script, options) => {
    if (!script)
        return [];
    const fromArgs = (args) => getBinariesFromScript(args.filter(arg => arg !== '--').join(' '), { ...options, knownGlobalsOnly: false });
    const getBinariesFromNodes = (nodes) => nodes.flatMap(node => {
        switch (node.type) {
            case 'Command': {
                const text = node.name?.text;
                const binary = text ? trimBinary(text) : text;
                const commandExpansions = node.prefix
                    ?.filter(isExpansion)
                    .map(prefix => prefix.expansion)
                    .flatMap(expansion => expansion.filter(expansion => expansion.type === 'CommandExpansion') ?? []) ?? [];
                if (commandExpansions.length > 0) {
                    return commandExpansions.flatMap(expansion => getBinariesFromNodes(expansion.commandAST.commands)) ?? [];
                }
                if (!binary || binary === '.' || binary === 'source' || binary === '[')
                    return [];
                if (binary.startsWith('-') || binary.startsWith('"') || binary.startsWith('..'))
                    return [];
                const args = node.suffix?.map(arg => arg.text) ?? [];
                if (['!', 'test'].includes(binary))
                    return fromArgs(args);
                const fromNodeOptions = node.prefix
                    ?.filter(isAssignment)
                    .filter(node => node.text.startsWith('NODE_OPTIONS='))
                    .flatMap(node => node.text.split('=')[1])
                    .map(arg => parseNodeArgs(arg.split(' ')))
                    .filter(args => args.require)
                    .flatMap(arg => arg.require) ?? [];
                if (binary in KnownResolvers) {
                    const resolver = KnownResolvers[binary];
                    return resolver(binary, args, { ...options, fromArgs });
                }
                if (spawningBinaries.includes(binary)) {
                    const command = script.replace(new RegExp(`.*${node.name?.text ?? binary}(\\s--\\s)?`), '');
                    return [toBinary(binary), ...getBinariesFromScript(command, options)];
                }
                if (options.knownGlobalsOnly && !text?.startsWith('.'))
                    return [];
                return [...FallbackResolver.resolve(binary, args, { ...options, fromArgs }), ...fromNodeOptions];
            }
            case 'LogicalExpression':
                return getBinariesFromNodes([node.left, node.right]);
            case 'If':
                return getBinariesFromNodes([node.clause, node.then, ...(node.else ? [node.else] : [])]);
            case 'For':
                return getBinariesFromNodes(node.do.commands);
            case 'CompoundList':
                return getBinariesFromNodes(node.commands);
            case 'Pipeline':
                return getBinariesFromNodes(node.commands);
            case 'Function':
                return getBinariesFromNodes(node.body.commands);
            default:
                return [];
        }
    });
    try {
        const parsed = parse(script);
        return parsed?.commands ? getBinariesFromNodes(parsed.commands) : [];
    }
    catch (error) {
        debugLogObject('*', 'Bash parser error', error);
        return [];
    }
};
